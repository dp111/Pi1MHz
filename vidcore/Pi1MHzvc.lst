Sections:
00: "org0001:0" (0-92)


Source: "Pi1MHzvc.s"
                            	     1: #-------------------------------------------------------------------------
                            	     2: # VideoCore IV implementation of 1MHz handler
                            	     3: #-------------------------------------------------------------------------
                            	     4: 
                            	     5: # on entry
                            	     6: # GPIO pins setup by arm
                            	     7: # Addresses passed into vc are VC based
                            	     8: # gpfsel_data_idle setup
                            	     9: 
                            	    10: #  r0 - pointer to shared memory ( VC address) of 1MHz registers
                            	    11: #  r1 - pointer to data to xfer to ARM
                            	    12: #  r2 -
                            	    13: #  r3 - data outputs
                            	    14: #  r4 - debug output control
                            	    15: #  r5 - debug pin mask (0 = no debug  xx= debug pin e.g 1<<21)
                            	    16: 
                            	    17: # Internal register allocation
                            	    18: #  r0 - pointer to shared memory ( VC address) of tube registers
                            	    19: #  r1 - pointer to data to xfer to ARM
                            	    20: #  r2 - unused
                            	    21: #  r3 -
                            	    22: #  r4 - debug output control
                            	    23: #  r5 - debug pin mask (0 = no debug  xx= debug pin e.g 1<<21)
                            	    24: #  r6 - GPFSEL0 constant
                            	    25: #  r7 - External nOE pin
                            	    26: #  r8 - temp
                            	    27: #  r9 - r9 Databus and test pin output select
                            	    28: # r10 - address mask
                            	    29: # r11 - (0xFF<<DATASHIFT)  # clear databus low
                            	    30: # r12 - GPIO pins value
                            	    31: # r13 - pointer to doorbell register
                            	    32: # r14 -
                            	    33: # r15 -
                            	    34: 
                            	    35: # GPIO registers
                            	    36: .equ GPFSEL0,       0x7e200000
                            	    37: .equ GPFSEL0_offset, 0
                            	    38: .equ GPSET0_offset, 0x1C
                            	    39: .equ GPCLR0_offset, 0x28
                            	    40: .equ GPLEV0_offset, 0x34
                            	    41: .equ GPEDS0_offset, 0x40
                            	    42: 
                            	    43: # fixed pin bit positions ( TEST passed in dynamically)
                            	    44: .equ nRST,         26
                            	    45: .equ nPCFD,        25
                            	    46: .equ nPCFC,        24
                            	    47: 
                            	    48: .equ RnW,          10
                            	    49: .equ CLK,          27
                            	    50: .equ DATASHIFT,    2
                            	    51: .equ ADDRBUS_SHIFT, (16)
                            	    52: .equ OUTPUTBIT,   (15)
                            	    53: 
                            	    54: .equ D7_PIN,       (9)
                            	    55: .equ D6_PIN,       (8)
                            	    56: .equ D5_PIN,       (7)
                            	    57: .equ D4_PIN,       (6)
                            	    58: .equ D3_PIN,       (5)
                            	    59: .equ D2_PIN,       (4)
                            	    60: .equ D1_PIN,       (3)
                            	    61: .equ D0_PIN,       (2)
                            	    62: 
                            	    63: .equ ADDRBUS_MASK,  (0xFF<<ADDRBUS_SHIFT)
                            	    64: .equ NPCFC_MASK,    (1<<nPCFC)
                            	    65: 
                            	    66: .equ Pi1MHz_MEM_RNW, (1<<9)
                            	    67: 
                            	    68: .equ GPU_ARM_DBELL, 0x7E00B844
                            	    69: 
                            	    70: .org 0
                            	    71: 
                            	    72: # disable interrupts
                            	    73: 
00:00000000 0500            	    74:   di
00:00000002 A9C1041F        	    75:    or     r9, r3, r4       # add in test pin so that it is still enabled
00:00000006 06E80000207E    	    76:    mov    r6, GPFSEL0
00:0000000C 1760            	    77:    mov    r7, 1            # external nOE pin
00:0000000E 0AE8FF010000    	    78:    mov    r10, ((ADDRBUS_MASK>>ADDRBUS_SHIFT) | (NPCFC_MASK>>ADDRBUS_SHIFT))
00:00000014 0BE8FC030000    	    79:    mov    r11, (0xFF<<DATASHIFT)  # clear databus low
00:0000001A 0DE844B8007E    	    80:    mov    r13, GPU_ARM_DBELL
                            	    81: 
                            	    82: # poll for nPCFC or nPCFD being low
                            	    83: 
                            	    84: Poll_loop:
00:00000020 653A            	    85:    st     r5, GPCLR0_offset(r6)  # Turn off debug signal
                            	    86: .balignw 4,1 # Align with nops
                            	    87: Poll_access_low:
00:00000024 6C2D            	    88:    ld     r12, GPLEV0_offset(r6)  # loop until we see FRED or JIM low
                            	    89: 
00:00000026 8C6D            	    90:    btst   r12, nPCFC
00:00000028 8CC1D960        	    91:    btstne r12, nPCFD
00:0000002C FC18            	    92:    bne    Poll_access_low
                            	    93: 
00:0000002E 6537            	    94:    st     r5, GPSET0_offset(r6)  # Debug pin
                            	    95: 
00:00000030 BC6D            	    96:    btst   r12, CLK
00:00000032 0818            	    97:    beq    waitforclkhigh
                            	    98: 
                            	    99: waitforclklow:                   # wait for extra half cycle to end
00:00000034 6C2D            	   100:    ld     r12, GPLEV0_offset(r6)
00:00000036 8C6D            	   101:    btst   r12, nPCFC
00:00000038 8CC1D960        	   102:    btstne r12, nPCFD
00:0000003C F218            	   103:    bne    Poll_loop
                            	   104: 
00:0000003E BC6D            	   105:    btst   r12, CLK
00:00000040 FA18            	   106:    bne    waitforclklow
                            	   107: 
                            	   108: waitforclkhigh:
                            	   109: 
                            	   110: waitforclkhighloop:
00:00000042 48C35067        	   111:    LSR    r8, r12,ADDRBUS_SHIFT
00:00000046 A847            	   112:    and    r8, r10                # Isolate address bus
00:00000048 48A00807        	   113:    ldh     r8, (r0,r8) # get byte to write out
00:0000004C 6C2D            	   114:    ld     r12, GPLEV0_offset(r6)
00:0000004E BC6D            	   115:    btst   r12, CLK
00:00000050 7918            	   116:    beq    waitforclkhighloop
                            	   117: 
                            	   118: # seen rising edge of CLK
                            	   119: # so address bus has now been setup
                            	   120: 
00:00000052 8C6D            	   121:    btst   r12, nPCFC
00:00000054 8CC1D960        	   122:    btstne r12, nPCFD
00:00000058 E418            	   123:    bne    Poll_loop
                            	   124: # check if we are in a read or write cycle
                            	   125: # we do this here while the read above is stalling
00:0000005A AC6C            	   126:    btst   r12, RnW
00:0000005C 1118            	   127:    beq    writecycle
                            	   128: 
00:0000005E 287C            	   129:    lsl  r8, DATASHIFT          # low 16 bits with databus shift
00:00000060 F86C            	   130:    btst   r8, OUTPUTBIT
00:00000062 B847            	   131:    and    r8, r11     # isolate databus
                            	   132: 
00:00000064 6837            	   133:    st     r8, GPSET0_offset(r6)  # set up databus
00:00000066 0318            	   134:    beq    skipenablingbus
00:00000068 6930            	   135:    st     r9, GPFSEL0_offset(r6) # set databus to output ( only if it has been written to)
00:0000006A 673A            	   136:    st     r7, GPCLR0_offset(r6)  # set external output enable low
                            	   137:  skipenablingbus:
00:0000006C 1C09            	   138:    st     r12, (r1)              # post data
00:0000006E DC09            	   139:    st     r12, (r13)             # ring doorbell
                            	   140: 
                            	   141: .balignw 4,1 # Align with nops
                            	   142: waitforclklow2loop:
00:00000070 6C2D            	   143:    ld     r12, GPLEV0_offset(r6)
00:00000072 BC6D            	   144:    btst   r12, CLK
00:00000074 FE18            	   145:    bne    waitforclklow2loop
                            	   146: 
00:00000076 6737            	   147:    st     r7, GPSET0_offset(r6)  # set external output enable high
00:00000078 6430            	   148:    st     r4, GPFSEL0_offset(r6) # data bus to inputs except debug
00:0000007A 6B3A            	   149:    st     r11, GPCLR0_offset(r6)  # clear databus low (0xFF<<DATASHIFT)
                            	   150: 
00:0000007C 521F            	   151:    b      Poll_loop
                            	   152: 
                            	   153: writecycle:
00:0000007E 673A            	   154:    st     r7, GPCLR0_offset(r6)  # set external output enable low
                            	   155: waitforclkloww2:
00:00000080 682D            	   156:    ld     r8, GPLEV0_offset(r6)
00:00000082 B86D            	   157:    btst   r8, CLK
00:00000084 0CC08860        	   158:    movne  r12,r8
00:00000088 FC18            	   159:    bne    waitforclkloww2
00:0000008A 1C09            	   160:    st     r12, (r1)         # post data
00:0000008C DC09            	   161:    st     r12, (r13)        # ring doorbell
00:0000008E 6737            	   162:    st     r7, GPSET0_offset(r6)  # set external output enable high
00:00000090 481F            	   163:    b      Poll_loop
                            	   164: 


Symbols by name:
ADDRBUS_MASK                     S:00FF0000
ADDRBUS_SHIFT                    S:00000010
CLK                              S:0000001B
DATASHIFT                        S:00000002
GPCLR0_offset                    S:00000028
GPFSEL0                          S:7E200000
GPFSEL0_offset                   S:00000000
GPLEV0_offset                    S:00000034
GPSET0_offset                    S:0000001C
GPU_ARM_DBELL                    S:7E00B844
NPCFC_MASK                       S:01000000
OUTPUTBIT                        S:0000000F
Poll_access_low                  A:00000024
Poll_loop                        A:00000020
RnW                              S:0000000A
nPCFC                            S:00000018
nPCFD                            S:00000019
skipenablingbus                  A:0000006C
waitforclkhigh                   A:00000042
waitforclkhighloop               A:00000042
waitforclklow                    A:00000034
waitforclklow2loop               A:00000070
waitforclkloww2                  A:00000080
writecycle                       A:0000007E

Symbols by value:
00000000 GPFSEL0_offset
00000002 DATASHIFT
0000000A RnW
0000000F OUTPUTBIT
00000010 ADDRBUS_SHIFT
00000018 nPCFC
00000019 nPCFD
0000001B CLK
0000001C GPSET0_offset
00000020 Poll_loop
00000024 Poll_access_low
00000028 GPCLR0_offset
00000034 GPLEV0_offset
00000034 waitforclklow
00000042 waitforclkhigh
00000042 waitforclkhighloop
0000006C skipenablingbus
00000070 waitforclklow2loop
0000007E writecycle
00000080 waitforclkloww2
00FF0000 ADDRBUS_MASK
01000000 NPCFC_MASK
7E00B844 GPU_ARM_DBELL
7E200000 GPFSEL0
